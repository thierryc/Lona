// Generated by BUCKLESCRIPT VERSION 3.1.5, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var LodashUpperfirst = require("lodash.upperfirst");
var Layer$LonaCompilerCore = require("../core/layer.bs.js");
var Logic$LonaCompilerCore = require("../core/logic.bs.js");
var Types$LonaCompilerCore = require("../core/types.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Decode$LonaCompilerCore = require("../core/decode.bs.js");
var Plugin$LonaCompilerCore = require("../core/plugin.bs.js");
var Constraint$LonaCompilerCore = require("../utils/constraint.bs.js");
var SwiftLogic$LonaCompilerCore = require("./swiftLogic.bs.js");
var SwiftFormat$LonaCompilerCore = require("./swiftFormat.bs.js");
var ParameterKey$LonaCompilerCore = require("../core/parameterKey.bs.js");
var ParameterMap$LonaCompilerCore = require("../containers/parameterMap.bs.js");
var SwiftOptions$LonaCompilerCore = require("./swiftOptions.bs.js");
var SwiftDocument$LonaCompilerCore = require("./swiftDocument.bs.js");
var AppkitPressable$LonaCompilerCore = require("./appkit/appkitPressable.bs.js");
var SwiftHelperClass$LonaCompilerCore = require("./swiftHelperClass.bs.js");

function isFunctionParameter(param) {
  return Caml_obj.caml_equal(param[/* ltype */1], Types$LonaCompilerCore.handlerType);
}

function generate(config, options, swiftOptions, name, colors, textStyles, getComponent, json) {
  var rootLayer = Decode$LonaCompilerCore.Component[/* rootLayer */1](getComponent, json);
  var nonRootLayers = List.tl(Layer$LonaCompilerCore.flatten(rootLayer));
  var logic = Decode$LonaCompilerCore.Component[/* logic */2](json);
  var textLayers = List.filter(Layer$LonaCompilerCore.isTextLayer)(nonRootLayers);
  var imageLayers = List.filter(Layer$LonaCompilerCore.isImageLayer)(nonRootLayers);
  var pressableLayers = List.filter((function (param) {
            return Logic$LonaCompilerCore.isLayerParameterAssigned(logic, "onPress", param);
          }))(Layer$LonaCompilerCore.flatten(rootLayer));
  var needsTracking = swiftOptions[/* framework */0] === /* AppKit */1 && List.length(pressableLayers) > 0;
  var layerParameterAssignments = Layer$LonaCompilerCore.logicAssignmentsFromLayerParameters(rootLayer);
  var assignments = Layer$LonaCompilerCore.parameterAssignmentsFromLogic(rootLayer, logic);
  var parameters = Decode$LonaCompilerCore.Component[/* parameters */0](json);
  var isParameterAssigned = function (layer, parameter) {
    var assignedParameters = Layer$LonaCompilerCore.LayerMap[/* find_opt */24](layer, layerParameterAssignments);
    if (assignedParameters) {
      return Curry._2(ParameterMap$LonaCompilerCore.mem, parameter, assignedParameters[0]);
    } else {
      return false;
    }
  };
  var isParameterUsed = function (layer, parameter) {
    if (isParameterAssigned(layer, parameter)) {
      return true;
    } else {
      return Curry._2(ParameterMap$LonaCompilerCore.mem, parameter, layer[/* parameters */2]);
    }
  };
  var parameterVariableDoc = function (parameter) {
    return /* VariableDeclaration */Block.__(10, [{
                modifiers: /* :: */[
                  /* AccessLevelModifier */Block.__(0, [/* PublicModifier */3]),
                  /* [] */0
                ],
                pattern: /* IdentifierPattern */Block.__(0, [{
                      identifier: /* SwiftIdentifier */Block.__(8, [ParameterKey$LonaCompilerCore.toString(parameter[/* name */0])]),
                      annotation: /* Some */[SwiftDocument$LonaCompilerCore.typeAnnotationDoc(swiftOptions[/* framework */0], parameter[/* ltype */1])]
                    }]),
                init: /* None */0,
                block: /* Some */[/* WillSetDidSetBlock */[{
                      willSet: /* None */0,
                      didSet: /* Some */[/* :: */[
                          /* FunctionCallExpression */Block.__(19, [{
                                name: /* SwiftIdentifier */Block.__(8, ["update"]),
                                arguments: /* [] */0
                              }]),
                          /* [] */0
                        ]]
                    }]]
              }]);
  };
  var pluginContext = {
    target: "swift",
    framework: SwiftOptions$LonaCompilerCore.frameworkToString(swiftOptions[/* framework */0])
  };
  var getLayerTypeName = function (layerType) {
    var match = swiftOptions[/* framework */0];
    var typeName;
    if (match) {
      if (typeof layerType === "number") {
        switch (layerType) {
          case 0 : 
              typeName = "NSBox";
              break;
          case 1 : 
              typeName = "NSTextField";
              break;
          case 2 : 
              typeName = "NSImageView";
              break;
          case 3 : 
          case 4 : 
          case 5 : 
              typeName = "TypeUnknown";
              break;
          
        }
      } else {
        typeName = layerType[0];
      }
    } else if (typeof layerType === "number") {
      switch (layerType) {
        case 0 : 
            typeName = "UIView";
            break;
        case 1 : 
            typeName = "UILabel";
            break;
        case 2 : 
            typeName = "UIImageView";
            break;
        case 3 : 
        case 4 : 
        case 5 : 
            typeName = "TypeUnknown";
            break;
        
      }
    } else {
      typeName = layerType[0];
    }
    return Plugin$LonaCompilerCore.applyTransformTypePlugins(config[/* plugins */0], pluginContext, name, typeName);
  };
  var getLayerInitCall = function (layer) {
    var typeName = /* SwiftIdentifier */Block.__(8, [getLayerTypeName(layer[/* typeName */0])]);
    var match = swiftOptions[/* framework */0];
    var match$1 = layer[/* typeName */0];
    if (match) {
      if (typeof match$1 === "number") {
        if (match$1 >= 3) {
          return /* FunctionCallExpression */Block.__(19, [{
                      name: typeName,
                      arguments: /* [] */0
                    }]);
        } else {
          switch (match$1) {
            case 0 : 
                return /* FunctionCallExpression */Block.__(19, [{
                            name: typeName,
                            arguments: /* [] */0
                          }]);
            case 1 : 
                return /* FunctionCallExpression */Block.__(19, [{
                            name: typeName,
                            arguments: /* :: */[
                              /* FunctionCallArgument */Block.__(18, [{
                                    name: /* Some */[/* SwiftIdentifier */Block.__(8, ["labelWithString"])],
                                    value: /* LiteralExpression */Block.__(0, [/* String */Block.__(3, [""])])
                                  }]),
                              /* [] */0
                            ]
                          }]);
            case 2 : 
                var hasBackground = isParameterAssigned(layer, /* BackgroundColor */8);
                return /* FunctionCallExpression */Block.__(19, [{
                            name: hasBackground ? /* SwiftIdentifier */Block.__(8, ["ImageWithBackgroundColor"]) : typeName,
                            arguments: /* [] */0
                          }]);
            
          }
        }
      } else {
        return /* FunctionCallExpression */Block.__(19, [{
                    name: typeName,
                    arguments: /* [] */0
                  }]);
      }
    } else if (typeof match$1 === "number") {
      if (match$1 !== 1) {
        if (match$1 >= 3) {
          return /* FunctionCallExpression */Block.__(19, [{
                      name: typeName,
                      arguments: /* [] */0
                    }]);
        } else {
          return /* FunctionCallExpression */Block.__(19, [{
                      name: typeName,
                      arguments: /* :: */[
                        /* FunctionCallArgument */Block.__(18, [{
                              name: /* Some */[/* SwiftIdentifier */Block.__(8, ["frame"])],
                              value: /* SwiftIdentifier */Block.__(8, [".zero"])
                            }]),
                        /* [] */0
                      ]
                    }]);
        }
      } else {
        return /* FunctionCallExpression */Block.__(19, [{
                    name: typeName,
                    arguments: /* [] */0
                  }]);
      }
    } else {
      return /* FunctionCallExpression */Block.__(19, [{
                  name: typeName,
                  arguments: /* [] */0
                }]);
    }
  };
  var viewVariableDoc = function (layer) {
    return /* VariableDeclaration */Block.__(10, [{
                modifiers: /* :: */[
                  /* AccessLevelModifier */Block.__(0, [/* PrivateModifier */0]),
                  /* [] */0
                ],
                pattern: /* IdentifierPattern */Block.__(0, [{
                      identifier: /* SwiftIdentifier */Block.__(8, [SwiftFormat$LonaCompilerCore.layerName(layer[/* name */1])]),
                      annotation: /* None */0
                    }]),
                init: /* Some */[getLayerInitCall(layer)],
                block: /* None */0
              }]);
  };
  var textStyleVariableDoc = function (layer) {
    var match = Curry._2(ParameterMap$LonaCompilerCore.mem, /* TextStyle */3, layer[/* parameters */2]);
    var styleName = /* MemberExpression */Block.__(1, [/* :: */[
          /* SwiftIdentifier */Block.__(8, ["TextStyles"]),
          /* :: */[
            /* SwiftIdentifier */Block.__(8, [match ? Layer$LonaCompilerCore.getStringParameter(/* TextStyle */3, layer) : textStyles[/* defaultStyle */1][/* id */0]]),
            /* [] */0
          ]
        ]]);
    var match$1 = Curry._2(ParameterMap$LonaCompilerCore.mem, /* TextAlign */2, layer[/* parameters */2]);
    var styleName$1 = match$1 ? /* MemberExpression */Block.__(1, [/* :: */[
            styleName,
            /* :: */[
              /* FunctionCallExpression */Block.__(19, [{
                    name: /* SwiftIdentifier */Block.__(8, ["with"]),
                    arguments: /* :: */[
                      /* FunctionCallArgument */Block.__(18, [{
                            name: /* Some */[/* SwiftIdentifier */Block.__(8, ["alignment"])],
                            value: /* SwiftIdentifier */Block.__(8, ["." + Layer$LonaCompilerCore.getStringParameter(/* TextAlign */2, layer)])
                          }]),
                      /* [] */0
                    ]
                  }]),
              /* [] */0
            ]
          ]]) : styleName;
    return /* VariableDeclaration */Block.__(10, [{
                modifiers: /* :: */[
                  /* AccessLevelModifier */Block.__(0, [/* PrivateModifier */0]),
                  /* [] */0
                ],
                pattern: /* IdentifierPattern */Block.__(0, [{
                      identifier: /* SwiftIdentifier */Block.__(8, [SwiftFormat$LonaCompilerCore.layerName(layer[/* name */1]) + "TextStyle"]),
                      annotation: /* None */0
                    }]),
                init: /* Some */[styleName$1],
                block: /* None */0
              }]);
  };
  var spacingVariableDoc = function (layer) {
    var variableName = function (variable) {
      var match = layer === rootLayer;
      if (match) {
        return variable;
      } else {
        return SwiftFormat$LonaCompilerCore.layerName(layer[/* name */1]) + LodashUpperfirst(variable);
      }
    };
    var match = layer === rootLayer;
    var marginVariables;
    if (match) {
      marginVariables = /* [] */0;
    } else {
      var createVariable = function (marginParameter) {
        return /* VariableDeclaration */Block.__(10, [{
                    modifiers: /* :: */[
                      /* AccessLevelModifier */Block.__(0, [/* PrivateModifier */0]),
                      /* [] */0
                    ],
                    pattern: /* IdentifierPattern */Block.__(0, [{
                          identifier: /* SwiftIdentifier */Block.__(8, [variableName(marginParameter[/* swiftName */1])]),
                          annotation: /* Some */[/* TypeName */Block.__(0, ["CGFloat"])]
                        }]),
                    init: /* Some */[/* LiteralExpression */Block.__(0, [/* FloatingPoint */Block.__(2, [Layer$LonaCompilerCore.getNumberParameter(marginParameter[/* lonaName */0], layer)])])],
                    block: /* None */0
                  }]);
      };
      marginVariables = List.map(createVariable, /* :: */[
            /* record */[
              /* lonaName : MarginTop */12,
              /* swiftName */"topMargin"
            ],
            /* :: */[
              /* record */[
                /* lonaName : MarginRight */13,
                /* swiftName */"trailingMargin"
              ],
              /* :: */[
                /* record */[
                  /* lonaName : MarginBottom */14,
                  /* swiftName */"bottomMargin"
                ],
                /* :: */[
                  /* record */[
                    /* lonaName : MarginLeft */15,
                    /* swiftName */"leadingMargin"
                  ],
                  /* [] */0
                ]
              ]
            ]
          ]);
    }
    var match$1 = layer[/* children */3];
    var paddingVariables;
    if (match$1) {
      var createVariable$1 = function (paddingParameter) {
        return /* VariableDeclaration */Block.__(10, [{
                    modifiers: /* :: */[
                      /* AccessLevelModifier */Block.__(0, [/* PrivateModifier */0]),
                      /* [] */0
                    ],
                    pattern: /* IdentifierPattern */Block.__(0, [{
                          identifier: /* SwiftIdentifier */Block.__(8, [variableName(paddingParameter[/* swiftName */1])]),
                          annotation: /* Some */[/* TypeName */Block.__(0, ["CGFloat"])]
                        }]),
                    init: /* Some */[/* LiteralExpression */Block.__(0, [/* FloatingPoint */Block.__(2, [Layer$LonaCompilerCore.getNumberParameter(paddingParameter[/* lonaName */0], layer)])])],
                    block: /* None */0
                  }]);
      };
      paddingVariables = List.map(createVariable$1, /* :: */[
            /* record */[
              /* lonaName : PaddingTop */16,
              /* swiftName */"topPadding"
            ],
            /* :: */[
              /* record */[
                /* lonaName : PaddingRight */17,
                /* swiftName */"trailingPadding"
              ],
              /* :: */[
                /* record */[
                  /* lonaName : PaddingBottom */18,
                  /* swiftName */"bottomPadding"
                ],
                /* :: */[
                  /* record */[
                    /* lonaName : PaddingLeft */19,
                    /* swiftName */"leadingPadding"
                  ],
                  /* [] */0
                ]
              ]
            ]
          ]);
    } else {
      paddingVariables = /* [] */0;
    }
    return Pervasives.$at(marginVariables, paddingVariables);
  };
  var pressableVariableDoc = function (layer) {
    return /* :: */[
            /* VariableDeclaration */Block.__(10, [{
                  modifiers: /* :: */[
                    /* AccessLevelModifier */Block.__(0, [/* PrivateModifier */0]),
                    /* [] */0
                  ],
                  pattern: /* IdentifierPattern */Block.__(0, [{
                        identifier: /* SwiftIdentifier */Block.__(8, [SwiftFormat$LonaCompilerCore.layerVariableName(rootLayer, layer, "hovered")]),
                        annotation: /* None */0
                      }]),
                  init: /* Some */[/* LiteralExpression */Block.__(0, [/* Boolean */Block.__(0, [false])])],
                  block: /* None */0
                }]),
            /* :: */[
              /* VariableDeclaration */Block.__(10, [{
                    modifiers: /* :: */[
                      /* AccessLevelModifier */Block.__(0, [/* PrivateModifier */0]),
                      /* [] */0
                    ],
                    pattern: /* IdentifierPattern */Block.__(0, [{
                          identifier: /* SwiftIdentifier */Block.__(8, [SwiftFormat$LonaCompilerCore.layerVariableName(rootLayer, layer, "pressed")]),
                          annotation: /* None */0
                        }]),
                    init: /* Some */[/* LiteralExpression */Block.__(0, [/* Boolean */Block.__(0, [false])])],
                    block: /* None */0
                  }]),
              /* :: */[
                /* VariableDeclaration */Block.__(10, [{
                      modifiers: /* :: */[
                        /* AccessLevelModifier */Block.__(0, [/* PrivateModifier */0]),
                        /* [] */0
                      ],
                      pattern: /* IdentifierPattern */Block.__(0, [{
                            identifier: /* SwiftIdentifier */Block.__(8, [SwiftFormat$LonaCompilerCore.layerVariableName(rootLayer, layer, "onPress")]),
                            annotation: /* Some */[/* OptionalType */Block.__(4, [/* TypeName */Block.__(0, ["(() -> Void)"])])]
                          }]),
                      init: /* None */0,
                      block: /* None */0
                    }]),
                /* [] */0
              ]
            ]
          ];
  };
  var initParameterDoc = function (parameter) {
    return /* Parameter */Block.__(17, [{
                externalName: /* None */0,
                localName: ParameterKey$LonaCompilerCore.toString(parameter[/* name */0]),
                annotation: SwiftDocument$LonaCompilerCore.typeAnnotationDoc(swiftOptions[/* framework */0], parameter[/* ltype */1]),
                defaultValue: /* None */0
              }]);
  };
  var initParameterAssignmentDoc = function (parameter) {
    return /* BinaryExpression */Block.__(2, [{
                left: /* MemberExpression */Block.__(1, [/* :: */[
                      /* SwiftIdentifier */Block.__(8, ["self"]),
                      /* :: */[
                        /* SwiftIdentifier */Block.__(8, [ParameterKey$LonaCompilerCore.toString(parameter[/* name */0])]),
                        /* [] */0
                      ]
                    ]]),
                operator: "=",
                right: /* SwiftIdentifier */Block.__(8, [ParameterKey$LonaCompilerCore.toString(parameter[/* name */0])])
              }]);
  };
  var initializerCoderDoc = function () {
    return /* InitializerDeclaration */Block.__(11, [{
                modifiers: /* :: */[
                  /* AccessLevelModifier */Block.__(0, [/* PublicModifier */3]),
                  /* :: */[
                    /* RequiredModifier */10,
                    /* [] */0
                  ]
                ],
                parameters: /* :: */[
                  /* Parameter */Block.__(17, [{
                        externalName: /* Some */["coder"],
                        localName: "aDecoder",
                        annotation: /* TypeName */Block.__(0, ["NSCoder"]),
                        defaultValue: /* None */0
                      }]),
                  /* [] */0
                ],
                failable: /* Some */["?"],
                throws: false,
                body: /* :: */[
                  /* FunctionCallExpression */Block.__(19, [{
                        name: /* SwiftIdentifier */Block.__(8, ["fatalError"]),
                        arguments: /* :: */[
                          /* FunctionCallArgument */Block.__(18, [{
                                name: /* None */0,
                                value: /* SwiftIdentifier */Block.__(8, ["\"init(coder:) has not been implemented\""])
                              }]),
                          /* [] */0
                        ]
                      }]),
                  /* [] */0
                ]
              }]);
  };
  var initializerDoc = function () {
    return /* InitializerDeclaration */Block.__(11, [{
                modifiers: /* :: */[
                  /* AccessLevelModifier */Block.__(0, [/* PublicModifier */3]),
                  /* [] */0
                ],
                parameters: List.map(initParameterDoc, List.filter((function (param) {
                              return !Caml_obj.caml_equal(param[/* ltype */1], Types$LonaCompilerCore.handlerType);
                            }))(parameters)),
                failable: /* None */0,
                throws: false,
                body: SwiftDocument$LonaCompilerCore.joinGroups(/* Empty */0, /* :: */[
                      List.map(initParameterAssignmentDoc, List.filter((function (param) {
                                    return !Caml_obj.caml_equal(param[/* ltype */1], Types$LonaCompilerCore.handlerType);
                                  }))(parameters)),
                      /* :: */[
                        /* :: */[
                          /* MemberExpression */Block.__(1, [/* :: */[
                                /* SwiftIdentifier */Block.__(8, ["super"]),
                                /* :: */[
                                  /* FunctionCallExpression */Block.__(19, [{
                                        name: /* SwiftIdentifier */Block.__(8, ["init"]),
                                        arguments: /* :: */[
                                          /* FunctionCallArgument */Block.__(18, [{
                                                name: /* Some */[/* SwiftIdentifier */Block.__(8, ["frame"])],
                                                value: /* SwiftIdentifier */Block.__(8, [".zero"])
                                              }]),
                                          /* [] */0
                                        ]
                                      }]),
                                  /* [] */0
                                ]
                              ]]),
                          /* [] */0
                        ],
                        /* :: */[
                          /* :: */[
                            /* FunctionCallExpression */Block.__(19, [{
                                  name: /* SwiftIdentifier */Block.__(8, ["setUpViews"]),
                                  arguments: /* [] */0
                                }]),
                            /* :: */[
                              /* FunctionCallExpression */Block.__(19, [{
                                    name: /* SwiftIdentifier */Block.__(8, ["setUpConstraints"]),
                                    arguments: /* [] */0
                                  }]),
                              /* [] */0
                            ]
                          ],
                          /* :: */[
                            /* :: */[
                              /* FunctionCallExpression */Block.__(19, [{
                                    name: /* SwiftIdentifier */Block.__(8, ["update"]),
                                    arguments: /* [] */0
                                  }]),
                              /* [] */0
                            ],
                            /* :: */[
                              needsTracking ? /* :: */[
                                  AppkitPressable$LonaCompilerCore.addTrackingArea,
                                  /* [] */0
                                ] : /* [] */0,
                              /* [] */0
                            ]
                          ]
                        ]
                      ]
                    ])
              }]);
  };
  var convenienceInitializerDoc = function () {
    return /* InitializerDeclaration */Block.__(11, [{
                modifiers: /* :: */[
                  /* AccessLevelModifier */Block.__(0, [/* PublicModifier */3]),
                  /* :: */[
                    /* ConvenienceModifier */1,
                    /* [] */0
                  ]
                ],
                parameters: /* [] */0,
                failable: /* None */0,
                throws: false,
                body: SwiftDocument$LonaCompilerCore.joinGroups(/* Empty */0, /* :: */[
                      /* :: */[
                        /* MemberExpression */Block.__(1, [/* :: */[
                              /* SwiftIdentifier */Block.__(8, ["self"]),
                              /* :: */[
                                /* FunctionCallExpression */Block.__(19, [{
                                      name: /* SwiftIdentifier */Block.__(8, ["init"]),
                                      arguments: List.map((function (param) {
                                              return /* FunctionCallArgument */Block.__(18, [{
                                                          name: /* Some */[/* SwiftIdentifier */Block.__(8, [ParameterKey$LonaCompilerCore.toString(param[/* name */0])])],
                                                          value: SwiftDocument$LonaCompilerCore.defaultValueForLonaType(swiftOptions[/* framework */0], colors, textStyles, param[/* ltype */1])
                                                        }]);
                                            }), List.filter((function (param) {
                                                    return !Caml_obj.caml_equal(param[/* ltype */1], Types$LonaCompilerCore.handlerType);
                                                  }))(parameters))
                                    }]),
                                /* [] */0
                              ]
                            ]]),
                        /* [] */0
                      ],
                      /* [] */0
                    ])
              }]);
  };
  var memberOrSelfExpression = function (firstIdentifier, statements) {
    if (firstIdentifier === "self") {
      return /* MemberExpression */Block.__(1, [statements]);
    } else {
      return /* MemberExpression */Block.__(1, [Pervasives.$at(/* :: */[
                      /* SwiftIdentifier */Block.__(8, [firstIdentifier]),
                      /* [] */0
                    ], statements)]);
    }
  };
  var parentNameOrSelf = function (parent) {
    var match = parent === rootLayer;
    if (match) {
      return "self";
    } else {
      return SwiftFormat$LonaCompilerCore.layerName(parent[/* name */1]);
    }
  };
  var defineInitialLayerValue = function (layer, param) {
    var name = param[0];
    var parameters = Layer$LonaCompilerCore.LayerMap[/* find_opt */24](layer, layerParameterAssignments);
    if (parameters) {
      var assignment = ParameterMap$LonaCompilerCore.find_opt(name, parameters[0]);
      var parameterValue = ParameterMap$LonaCompilerCore.find_opt(name, layer[/* parameters */2]);
      var match = layer[/* typeName */0];
      var logic;
      if (assignment) {
        logic = assignment[0];
      } else if (typeof match === "number") {
        logic = parameterValue ? Logic$LonaCompilerCore.assignmentForLayerParameter(layer, name, parameterValue[0]) : Logic$LonaCompilerCore.defaultAssignmentForLayerParameter(colors, textStyles, layer, name);
      } else {
        var param$1 = List.find((function (param) {
                return Caml_obj.caml_equal(param[/* name */0], name);
              }), Decode$LonaCompilerCore.Component[/* parameters */0](Curry._1(getComponent, match[0])));
        logic = Logic$LonaCompilerCore.assignmentForLayerParameter(layer, name, Logic$LonaCompilerCore.defaultValueForType(param$1[/* ltype */1]));
      }
      var node = SwiftLogic$LonaCompilerCore.toSwiftAST(swiftOptions, colors, textStyles, rootLayer, logic);
      return /* StatementListHelper */Block.__(25, [node]);
    } else {
      return /* LineComment */Block.__(21, [layer[/* name */1]]);
    }
  };
  var containsImageWithBackgroundColor = function () {
    var hasBackgroundColor = function (layer) {
      return isParameterAssigned(layer, /* BackgroundColor */8);
    };
    return List.exists(hasBackgroundColor, imageLayers);
  };
  var match = swiftOptions[/* framework */0];
  var helperClasses;
  if (match) {
    var match$1 = containsImageWithBackgroundColor(/* () */0);
    helperClasses = match$1 ? List.concat(/* :: */[
            /* :: */[
              /* LineComment */Block.__(21, ["MARK: - ImageWithBackgroundColor"]),
              /* :: */[
                /* Empty */0,
                /* [] */0
              ]
            ],
            /* :: */[
              SwiftHelperClass$LonaCompilerCore.generateImageWithBackgroundColor(options, swiftOptions),
              /* [] */0
            ]
          ]) : /* [] */0;
  } else {
    helperClasses = /* [] */0;
  }
  var setUpViewsDoc = function (root) {
    var setUpDefaultsDoc = function () {
      var filterParameters = function (param) {
        var name = param[0];
        if (name !== /* FlexDirection */10 && name !== /* JustifyContent */11 && name !== /* AlignSelf */7 && name !== /* AlignItems */6 && name !== /* Flex */9 && name !== /* PaddingTop */16 && name !== /* PaddingRight */17 && name !== /* PaddingBottom */18 && name !== /* PaddingLeft */19 && name !== /* MarginTop */12 && name !== /* MarginRight */13 && name !== /* MarginBottom */14 && name !== /* MarginLeft */15 && name !== /* Height */24 && name !== /* Width */23) {
          return name !== /* TextAlign */2;
        } else {
          return false;
        }
      };
      var defineInitialLayerValues = function (layer) {
        return List.map((function (param) {
                      return defineInitialLayerValue(layer, /* tuple */[
                                  param[0],
                                  param[1]
                                ]);
                    }), List.filter((function (param) {
                            var layer$1 = layer;
                            var param$1 = param;
                            var match = Layer$LonaCompilerCore.LayerMap[/* find_opt */24](layer$1, assignments);
                            if (match) {
                              var match$1 = ParameterMap$LonaCompilerCore.find_opt(param$1[0], match[0]);
                              if (match$1) {
                                return false;
                              } else {
                                return true;
                              }
                            } else {
                              return true;
                            }
                          }))(List.filter(filterParameters)(Curry._1(ParameterMap$LonaCompilerCore.bindings, layer[/* parameters */2]))));
      };
      return List.concat(List.map(defineInitialLayerValues, Layer$LonaCompilerCore.flatten(rootLayer)));
    };
    var resetViewStyling = function (layer) {
      var match = swiftOptions[/* framework */0];
      var match$1 = layer[/* typeName */0];
      if (match) {
        if (typeof match$1 === "number") {
          if (match$1 !== 1) {
            if (match$1 !== 0) {
              return /* [] */0;
            } else {
              var match$2 = isParameterUsed(layer, /* BorderWidth */21);
              return /* :: */[
                      /* BinaryExpression */Block.__(2, [{
                            left: memberOrSelfExpression(parentNameOrSelf(layer), /* :: */[
                                  /* SwiftIdentifier */Block.__(8, ["boxType"]),
                                  /* [] */0
                                ]),
                            operator: "=",
                            right: /* SwiftIdentifier */Block.__(8, [".custom"])
                          }]),
                      /* :: */[
                        /* BinaryExpression */Block.__(2, [{
                              left: memberOrSelfExpression(parentNameOrSelf(layer), /* :: */[
                                    /* SwiftIdentifier */Block.__(8, ["borderType"]),
                                    /* [] */0
                                  ]),
                              operator: "=",
                              right: match$2 ? /* SwiftIdentifier */Block.__(8, [".lineBorder"]) : /* SwiftIdentifier */Block.__(8, [".noBorder"])
                            }]),
                        /* :: */[
                          /* BinaryExpression */Block.__(2, [{
                                left: memberOrSelfExpression(parentNameOrSelf(layer), /* :: */[
                                      /* SwiftIdentifier */Block.__(8, ["contentViewMargins"]),
                                      /* [] */0
                                    ]),
                                operator: "=",
                                right: /* SwiftIdentifier */Block.__(8, [".zero"])
                              }]),
                          /* [] */0
                        ]
                      ]
                    ];
            }
          } else {
            return /* :: */[
                    /* BinaryExpression */Block.__(2, [{
                          left: memberOrSelfExpression(parentNameOrSelf(layer), /* :: */[
                                /* SwiftIdentifier */Block.__(8, ["lineBreakMode"]),
                                /* [] */0
                              ]),
                          operator: "=",
                          right: /* SwiftIdentifier */Block.__(8, [".byWordWrapping"])
                        }]),
                    /* [] */0
                  ];
          }
        } else {
          return /* [] */0;
        }
      } else if (typeof match$1 === "number" && match$1 === 1) {
        var match$3 = Curry._2(ParameterMap$LonaCompilerCore.mem, /* NumberOfLines */4, layer[/* parameters */2]);
        return List.concat(/* :: */[
                    match$3 ? /* [] */0 : /* :: */[
                        /* BinaryExpression */Block.__(2, [{
                              left: memberOrSelfExpression(parentNameOrSelf(layer), /* :: */[
                                    /* SwiftIdentifier */Block.__(8, ["numberOfLines"]),
                                    /* [] */0
                                  ]),
                              operator: "=",
                              right: /* LiteralExpression */Block.__(0, [/* Integer */Block.__(1, [0])])
                            }]),
                        /* [] */0
                      ],
                    /* [] */0
                  ]);
      } else {
        return /* [] */0;
      }
    };
    var addSubviews = function (parent, layer) {
      if (parent) {
        return /* :: */[
                /* FunctionCallExpression */Block.__(19, [{
                      name: memberOrSelfExpression(parentNameOrSelf(parent[0]), /* :: */[
                            /* SwiftIdentifier */Block.__(8, ["addSubview"]),
                            /* [] */0
                          ]),
                      arguments: /* :: */[
                        /* SwiftIdentifier */Block.__(8, [SwiftFormat$LonaCompilerCore.layerName(layer[/* name */1])]),
                        /* [] */0
                      ]
                    }]),
                /* [] */0
              ];
      } else {
        return /* [] */0;
      }
    };
    return /* FunctionDeclaration */Block.__(13, [{
                name: "setUpViews",
                modifiers: /* :: */[
                  /* AccessLevelModifier */Block.__(0, [/* PrivateModifier */0]),
                  /* [] */0
                ],
                parameters: /* [] */0,
                result: /* None */0,
                throws: false,
                body: SwiftDocument$LonaCompilerCore.joinGroups(/* Empty */0, /* :: */[
                      List.concat(Layer$LonaCompilerCore.flatmap(resetViewStyling, root)),
                      /* :: */[
                        List.concat(Layer$LonaCompilerCore.flatmapParent(addSubviews, root)),
                        /* :: */[
                          setUpDefaultsDoc(/* () */0),
                          /* [] */0
                        ]
                      ]
                    ])
              }]);
  };
  var negateNumber = function (expression) {
    return /* PrefixExpression */Block.__(3, [{
                operator: "-",
                expression: expression
              }]);
  };
  var constraintConstantExpression = function (layer, variable1, parent, variable2) {
    var variableName = function (layer, variable) {
      var match = layer === rootLayer;
      if (match) {
        return variable;
      } else {
        return SwiftFormat$LonaCompilerCore.layerName(layer[/* name */1]) + LodashUpperfirst(variable);
      }
    };
    return /* BinaryExpression */Block.__(2, [{
                left: /* SwiftIdentifier */Block.__(8, [variableName(layer, variable1)]),
                operator: "+",
                right: /* SwiftIdentifier */Block.__(8, [variableName(parent, variable2)])
              }]);
  };
  var generateConstraintWithInitialValue = function (constr, node) {
    if (constr.tag) {
      var statements_000 = /* SwiftIdentifier */Block.__(8, [Constraint$LonaCompilerCore.anchorToString(constr[4])]);
      var statements = /* :: */[
        statements_000,
        /* [] */0
      ];
      var statements_000$1 = /* SwiftIdentifier */Block.__(8, [Constraint$LonaCompilerCore.anchorToString(constr[1])]);
      var statements_001 = /* :: */[
        /* FunctionCallExpression */Block.__(19, [{
              name: /* SwiftIdentifier */Block.__(8, ["constraint"]),
              arguments: /* :: */[
                /* FunctionCallArgument */Block.__(18, [{
                      name: /* Some */[/* SwiftIdentifier */Block.__(8, [Constraint$LonaCompilerCore.cmpToString(constr[2])])],
                      value: memberOrSelfExpression(parentNameOrSelf(constr[3]), statements)
                    }]),
                /* :: */[
                  /* FunctionCallArgument */Block.__(18, [{
                        name: /* Some */[/* SwiftIdentifier */Block.__(8, ["constant"])],
                        value: node
                      }]),
                  /* [] */0
                ]
              ]
            }]),
        /* [] */0
      ];
      var statements$1 = /* :: */[
        statements_000$1,
        statements_001
      ];
      return memberOrSelfExpression(parentNameOrSelf(constr[0]), statements$1);
    } else {
      var statements_000$2 = /* SwiftIdentifier */Block.__(8, [Constraint$LonaCompilerCore.anchorToString(constr[1])]);
      var statements_001$1 = /* :: */[
        /* FunctionCallExpression */Block.__(19, [{
              name: /* SwiftIdentifier */Block.__(8, ["constraint"]),
              arguments: /* :: */[
                /* FunctionCallArgument */Block.__(18, [{
                      name: /* Some */[/* SwiftIdentifier */Block.__(8, ["equalToConstant"])],
                      value: node
                    }]),
                /* [] */0
              ]
            }]),
        /* [] */0
      ];
      var statements$2 = /* :: */[
        statements_000$2,
        statements_001$1
      ];
      return memberOrSelfExpression(parentNameOrSelf(constr[0]), statements$2);
    }
  };
  var generateConstantFromConstraint = function (constr) {
    if (constr.tag) {
      var match = constr[1];
      var child = constr[0];
      var exit = 0;
      switch (match) {
        case 0 : 
            if (constr[2] >= 2 && constr[4] === 0) {
              var match$1 = constr[6];
              var layer = constr[3];
              if (match$1 !== 7) {
                if (match$1 !== 8) {
                  console.log("Unknown constraint types");
                  throw Caml_builtin_exceptions.not_found;
                } else {
                  exit = 1;
                }
              } else {
                return negateNumber(/* BinaryExpression */Block.__(2, [{
                                left: constraintConstantExpression(layer, "leadingPadding", child, "leadingMargin"),
                                operator: "+",
                                right: constraintConstantExpression(layer, "trailingPadding", child, "trailingMargin")
                              }]));
              }
            } else {
              exit = 1;
            }
            break;
        case 1 : 
            if (constr[2] >= 2 && constr[4] === 1) {
              var match$2 = constr[6];
              var layer$1 = constr[3];
              if (match$2 !== 7) {
                if (match$2 !== 8) {
                  console.log("Unknown constraint types");
                  throw Caml_builtin_exceptions.not_found;
                } else {
                  exit = 1;
                }
              } else {
                return negateNumber(/* BinaryExpression */Block.__(2, [{
                                left: constraintConstantExpression(layer$1, "topPadding", child, "topMargin"),
                                operator: "+",
                                right: constraintConstantExpression(layer$1, "bottomPadding", child, "bottomMargin")
                              }]));
              }
            } else {
              exit = 1;
            }
            break;
        case 2 : 
            var match$3 = constr[4];
            var previousLayer = constr[3];
            if (match$3 !== 2) {
              if (match$3 !== 3) {
                exit = 1;
              } else {
                var match$4 = constr[6];
                if (match$4 !== 1) {
                  if (match$4 !== 8) {
                    console.log("Unknown constraint types");
                    throw Caml_builtin_exceptions.not_found;
                  } else {
                    exit = 1;
                  }
                } else {
                  return constraintConstantExpression(previousLayer, "bottomMargin", child, "topMargin");
                }
              }
            } else {
              switch (constr[6]) {
                case 0 : 
                case 4 : 
                    return constraintConstantExpression(previousLayer, "topPadding", child, "topMargin");
                case 8 : 
                    exit = 1;
                    break;
                case 1 : 
                case 2 : 
                case 3 : 
                case 5 : 
                case 6 : 
                case 7 : 
                case 9 : 
                case 10 : 
                    console.log("Unknown constraint types");
                    throw Caml_builtin_exceptions.not_found;
                
              }
            }
            break;
        case 3 : 
            if (constr[4] !== 3) {
              exit = 1;
            } else {
              var exit$1 = 0;
              switch (constr[6]) {
                case 2 : 
                case 5 : 
                    exit$1 = 2;
                    break;
                case 8 : 
                    exit = 1;
                    break;
                case 0 : 
                case 1 : 
                case 3 : 
                case 4 : 
                case 6 : 
                case 7 : 
                case 9 : 
                case 10 : 
                    console.log("Unknown constraint types");
                    throw Caml_builtin_exceptions.not_found;
                
              }
              if (exit$1 === 2) {
                return negateNumber(constraintConstantExpression(constr[3], "bottomPadding", child, "bottomMargin"));
              }
              
            }
            break;
        case 4 : 
            var match$5 = constr[4];
            var previousLayer$1 = constr[3];
            if (match$5 !== 4) {
              if (match$5 !== 5) {
                exit = 1;
              } else {
                var match$6 = constr[6];
                if (match$6 !== 1) {
                  if (match$6 !== 8) {
                    console.log("Unknown constraint types");
                    throw Caml_builtin_exceptions.not_found;
                  } else {
                    exit = 1;
                  }
                } else {
                  return constraintConstantExpression(previousLayer$1, "trailingMargin", child, "leadingMargin");
                }
              }
            } else {
              switch (constr[6]) {
                case 0 : 
                case 4 : 
                    return constraintConstantExpression(previousLayer$1, "leadingPadding", child, "leadingMargin");
                case 8 : 
                    exit = 1;
                    break;
                case 1 : 
                case 2 : 
                case 3 : 
                case 5 : 
                case 6 : 
                case 7 : 
                case 9 : 
                case 10 : 
                    console.log("Unknown constraint types");
                    throw Caml_builtin_exceptions.not_found;
                
              }
            }
            break;
        case 5 : 
            if (constr[4] !== 5) {
              exit = 1;
            } else {
              var exit$2 = 0;
              switch (constr[6]) {
                case 2 : 
                case 5 : 
                    exit$2 = 2;
                    break;
                case 8 : 
                    exit = 1;
                    break;
                case 0 : 
                case 1 : 
                case 3 : 
                case 4 : 
                case 6 : 
                case 7 : 
                case 9 : 
                case 10 : 
                    console.log("Unknown constraint types");
                    throw Caml_builtin_exceptions.not_found;
                
              }
              if (exit$2 === 2) {
                return negateNumber(constraintConstantExpression(constr[3], "trailingPadding", child, "trailingMargin"));
              }
              
            }
            break;
        case 6 : 
        case 7 : 
            exit = 1;
            break;
        
      }
      if (exit === 1) {
        if (constr[6] !== 8) {
          if (match !== 6) {
            if (match >= 7) {
              if (constr[4] >= 7) {
                return /* LiteralExpression */Block.__(0, [/* FloatingPoint */Block.__(2, [0.0])]);
              } else {
                console.log("Unknown constraint types");
                throw Caml_builtin_exceptions.not_found;
              }
            } else {
              console.log("Unknown constraint types");
              throw Caml_builtin_exceptions.not_found;
            }
          } else if (constr[4] !== 6) {
            console.log("Unknown constraint types");
            throw Caml_builtin_exceptions.not_found;
          } else {
            return /* LiteralExpression */Block.__(0, [/* FloatingPoint */Block.__(2, [0.0])]);
          }
        } else {
          return /* LiteralExpression */Block.__(0, [/* FloatingPoint */Block.__(2, [0.0])]);
        }
      }
      
    } else {
      var match$7 = constr[1];
      var layer$2 = constr[0];
      if (match$7 !== 1) {
        if (match$7 !== 0) {
          console.log("Unknown constraint types");
          throw Caml_builtin_exceptions.not_found;
        } else {
          var constant = Layer$LonaCompilerCore.getNumberParameter(/* Width */23, layer$2);
          return /* LiteralExpression */Block.__(0, [/* FloatingPoint */Block.__(2, [constant])]);
        }
      } else {
        var constant$1 = Layer$LonaCompilerCore.getNumberParameter(/* Height */24, layer$2);
        return /* LiteralExpression */Block.__(0, [/* FloatingPoint */Block.__(2, [constant$1])]);
      }
    }
  };
  var formatConstraintVariableName = function (constr) {
    var formatAnchorVariableName = function (layer, anchor, suffix) {
      var anchorString = Constraint$LonaCompilerCore.anchorToString(anchor);
      var match = layer === rootLayer;
      return (
              match ? anchorString : SwiftFormat$LonaCompilerCore.layerName(layer[/* name */1]) + LodashUpperfirst(anchorString)
            ) + suffix;
    };
    if (constr.tag) {
      var match = constr[6];
      var edge1 = constr[1];
      var layer1 = constr[0];
      if (match !== 7) {
        if (match !== 8) {
          return formatAnchorVariableName(layer1, edge1, "Constraint");
        } else {
          return SwiftFormat$LonaCompilerCore.layerName(layer1[/* name */1]) + (LodashUpperfirst(SwiftFormat$LonaCompilerCore.layerName(constr[3][/* name */1])) + (LodashUpperfirst(Constraint$LonaCompilerCore.anchorToString(edge1)) + "SiblingConstraint"));
        }
      } else {
        return formatAnchorVariableName(layer1, edge1, "ParentConstraint");
      }
    } else {
      return formatAnchorVariableName(constr[0], constr[1], "Constraint");
    }
  };
  var constraints = Constraint$LonaCompilerCore.getConstraints((function (layer, name) {
          var component = Curry._1(getComponent, name);
          var rootLayer = Decode$LonaCompilerCore.Component[/* rootLayer */1](getComponent, component);
          return /* record */[
                  /* typeName */layer[/* typeName */0],
                  /* name */layer[/* name */1],
                  /* parameters */rootLayer[/* parameters */2],
                  /* children */layer[/* children */3]
                ];
        }), rootLayer);
  var setUpConstraintsDoc = function (root) {
    var translatesAutoresizingMask = function (layer) {
      return /* BinaryExpression */Block.__(2, [{
                  left: memberOrSelfExpression(parentNameOrSelf(layer), /* :: */[
                        /* SwiftIdentifier */Block.__(8, ["translatesAutoresizingMaskIntoConstraints"]),
                        /* [] */0
                      ]),
                  operator: "=",
                  right: /* LiteralExpression */Block.__(0, [/* Boolean */Block.__(0, [false])])
                }]);
    };
    var defineConstraint = function (def) {
      return /* ConstantDeclaration */Block.__(9, [{
                  modifiers: /* [] */0,
                  init: /* Some */[generateConstraintWithInitialValue(def, generateConstantFromConstraint(def))],
                  pattern: /* IdentifierPattern */Block.__(0, [{
                        identifier: /* SwiftIdentifier */Block.__(8, [formatConstraintVariableName(def)]),
                        annotation: /* None */0
                      }])
                }]);
    };
    var setConstraintPriority = function (def) {
      var param = Constraint$LonaCompilerCore.getPriority(def);
      return /* BinaryExpression */Block.__(2, [{
                  left: /* MemberExpression */Block.__(1, [/* :: */[
                        /* SwiftIdentifier */Block.__(8, [formatConstraintVariableName(def)]),
                        /* :: */[
                          /* SwiftIdentifier */Block.__(8, ["priority"]),
                          /* [] */0
                        ]
                      ]]),
                  operator: "=",
                  right: /* MemberExpression */Block.__(1, [/* :: */[
                        SwiftDocument$LonaCompilerCore.layoutPriorityTypeDoc(swiftOptions[/* framework */0]),
                        /* :: */[
                          /* SwiftIdentifier */Block.__(8, [param ? "defaultLow" : "required"]),
                          /* [] */0
                        ]
                      ]])
                }]);
    };
    var activateConstraints = function () {
      return /* FunctionCallExpression */Block.__(19, [{
                  name: /* MemberExpression */Block.__(1, [/* :: */[
                        /* SwiftIdentifier */Block.__(8, ["NSLayoutConstraint"]),
                        /* :: */[
                          /* SwiftIdentifier */Block.__(8, ["activate"]),
                          /* [] */0
                        ]
                      ]]),
                  arguments: /* :: */[
                    /* FunctionCallArgument */Block.__(18, [{
                          name: /* None */0,
                          value: /* LiteralExpression */Block.__(0, [/* Array */Block.__(6, [List.map((function (def) {
                                          return /* SwiftIdentifier */Block.__(8, [formatConstraintVariableName(def)]);
                                        }), constraints)])])
                        }]),
                    /* [] */0
                  ]
                }]);
    };
    var assignConstraint = function (def) {
      return /* BinaryExpression */Block.__(2, [{
                  left: /* MemberExpression */Block.__(1, [/* :: */[
                        /* SwiftIdentifier */Block.__(8, ["self"]),
                        /* :: */[
                          /* SwiftIdentifier */Block.__(8, [formatConstraintVariableName(def)]),
                          /* [] */0
                        ]
                      ]]),
                  operator: "=",
                  right: /* SwiftIdentifier */Block.__(8, [formatConstraintVariableName(def)])
                }]);
    };
    var assignConstraintIdentifier = function (def) {
      return /* BinaryExpression */Block.__(2, [{
                  left: /* MemberExpression */Block.__(1, [/* :: */[
                        /* SwiftIdentifier */Block.__(8, [formatConstraintVariableName(def)]),
                        /* :: */[
                          /* SwiftIdentifier */Block.__(8, ["identifier"]),
                          /* [] */0
                        ]
                      ]]),
                  operator: "=",
                  right: /* LiteralExpression */Block.__(0, [/* String */Block.__(3, [formatConstraintVariableName(def)])])
                }]);
    };
    var match = List.length(constraints) > 0;
    var match$1 = List.length(constraints) > 0;
    return /* FunctionDeclaration */Block.__(13, [{
                name: "setUpConstraints",
                modifiers: /* :: */[
                  /* AccessLevelModifier */Block.__(0, [/* PrivateModifier */0]),
                  /* [] */0
                ],
                parameters: /* [] */0,
                result: /* None */0,
                throws: false,
                body: SwiftDocument$LonaCompilerCore.joinGroups(/* Empty */0, /* :: */[
                      Layer$LonaCompilerCore.flatmap(translatesAutoresizingMask, root),
                      /* :: */[
                        List.map(defineConstraint, constraints),
                        /* :: */[
                          List.map(setConstraintPriority, List.filter((function (def) {
                                        return Constraint$LonaCompilerCore.getPriority(def) === /* Low */1;
                                      }))(constraints)),
                          /* :: */[
                            match ? /* :: */[
                                activateConstraints(/* () */0),
                                /* [] */0
                              ] : /* [] */0,
                            /* :: */[
                              List.map(assignConstraint, constraints),
                              /* :: */[
                                match$1 ? /* :: */[
                                    /* LineComment */Block.__(21, ["For debugging"]),
                                    List.map(assignConstraintIdentifier, constraints)
                                  ] : /* [] */0,
                                /* [] */0
                              ]
                            ]
                          ]
                        ]
                      ]
                    ])
              }]);
  };
  var updateDoc = function () {
    var filterParameters = function (param) {
      var name = param[0];
      if (name !== /* PaddingTop */16 && name !== /* PaddingRight */17 && name !== /* PaddingBottom */18 && name !== /* PaddingLeft */19 && name !== /* MarginTop */12 && name !== /* MarginRight */13 && name !== /* MarginBottom */14) {
        return name !== /* MarginLeft */15;
      } else {
        return false;
      }
    };
    var conditionallyAssigned = Logic$LonaCompilerCore.conditionallyAssignedIdentifiers(logic);
    var defineInitialLayerValues = function (param) {
      var layer = param[0];
      return List.map((function (param) {
                    return defineInitialLayerValue(layer, param);
                  }), List.filter((function (param) {
                          var layer$1 = layer;
                          var param$1 = param;
                          var name = param$1[0];
                          var isAssigned = function (param) {
                            return Caml_obj.caml_equal(param[1], /* :: */[
                                        "layers",
                                        /* :: */[
                                          layer$1[/* name */1],
                                          /* :: */[
                                            ParameterKey$LonaCompilerCore.toString(name),
                                            /* [] */0
                                          ]
                                        ]
                                      ]);
                          };
                          return Curry._2(Logic$LonaCompilerCore.IdentifierSet[/* exists */15], isAssigned, conditionallyAssigned);
                        }))(List.filter(filterParameters)(Curry._1(ParameterMap$LonaCompilerCore.bindings, param[1]))));
    };
    return /* FunctionDeclaration */Block.__(13, [{
                name: "update",
                modifiers: /* :: */[
                  /* AccessLevelModifier */Block.__(0, [/* PrivateModifier */0]),
                  /* [] */0
                ],
                parameters: /* [] */0,
                result: /* None */0,
                throws: false,
                body: Pervasives.$at(List.concat(List.map(defineInitialLayerValues, Curry._1(Layer$LonaCompilerCore.LayerMap[/* bindings */16], assignments))), SwiftLogic$LonaCompilerCore.toSwiftAST(swiftOptions, colors, textStyles, rootLayer, logic))
              }]);
  };
  var match$2 = List.length(List.filter((function (param) {
                return !Caml_obj.caml_equal(param[/* ltype */1], Types$LonaCompilerCore.handlerType);
              }))(parameters)) > 0;
  var match$3 = List.length(parameters) > 0;
  return /* TopLevelDeclaration */Block.__(26, [{
              statements: SwiftDocument$LonaCompilerCore.joinGroups(/* Empty */0, /* :: */[
                    /* :: */[
                      SwiftDocument$LonaCompilerCore.importFramework(swiftOptions[/* framework */0]),
                      /* :: */[
                        /* ImportDeclaration */Block.__(14, ["Foundation"]),
                        /* [] */0
                      ]
                    ],
                    /* :: */[
                      helperClasses,
                      /* :: */[
                        /* :: */[
                          /* LineComment */Block.__(21, ["MARK: - " + name]),
                          /* [] */0
                        ],
                        /* :: */[
                          /* :: */[
                            /* ClassDeclaration */Block.__(5, [{
                                  name: name,
                                  inherits: /* :: */[
                                    /* TypeName */Block.__(0, [getLayerTypeName(/* View */0)]),
                                    /* [] */0
                                  ],
                                  modifier: /* Some */[/* PublicModifier */3],
                                  isFinal: false,
                                  body: SwiftDocument$LonaCompilerCore.joinGroups(/* Empty */0, /* :: */[
                                        /* :: */[
                                          /* Empty */0,
                                          /* :: */[
                                            /* LineComment */Block.__(21, ["MARK: Lifecycle"]),
                                            /* [] */0
                                          ]
                                        ],
                                        /* :: */[
                                          /* :: */[
                                            initializerDoc(/* () */0),
                                            /* [] */0
                                          ],
                                          /* :: */[
                                            match$2 ? /* :: */[
                                                convenienceInitializerDoc(/* () */0),
                                                /* [] */0
                                              ] : /* [] */0,
                                            /* :: */[
                                              /* :: */[
                                                initializerCoderDoc(/* () */0),
                                                /* [] */0
                                              ],
                                              /* :: */[
                                                needsTracking ? /* :: */[
                                                    AppkitPressable$LonaCompilerCore.deinitTrackingArea,
                                                    /* [] */0
                                                  ] : /* [] */0,
                                                /* :: */[
                                                  match$3 ? /* :: */[
                                                      /* LineComment */Block.__(21, ["MARK: Public"]),
                                                      /* [] */0
                                                    ] : /* [] */0,
                                                  /* :: */[
                                                    List.map(parameterVariableDoc, parameters),
                                                    /* :: */[
                                                      /* :: */[
                                                        /* LineComment */Block.__(21, ["MARK: Private"]),
                                                        /* [] */0
                                                      ],
                                                      /* :: */[
                                                        needsTracking ? /* :: */[
                                                            AppkitPressable$LonaCompilerCore.trackingAreaVar,
                                                            /* [] */0
                                                          ] : /* [] */0,
                                                        /* :: */[
                                                          List.map(viewVariableDoc, nonRootLayers),
                                                          /* :: */[
                                                            List.map(textStyleVariableDoc, textLayers),
                                                            /* :: */[
                                                              List.concat(Layer$LonaCompilerCore.flatmap(spacingVariableDoc, rootLayer)),
                                                              /* :: */[
                                                                List.concat(List.map(pressableVariableDoc, pressableLayers)),
                                                                /* :: */[
                                                                  List.map((function (def) {
                                                                          var variableName = formatConstraintVariableName(def);
                                                                          return /* VariableDeclaration */Block.__(10, [{
                                                                                      modifiers: /* :: */[
                                                                                        /* AccessLevelModifier */Block.__(0, [/* PrivateModifier */0]),
                                                                                        /* [] */0
                                                                                      ],
                                                                                      pattern: /* IdentifierPattern */Block.__(0, [{
                                                                                            identifier: /* SwiftIdentifier */Block.__(8, [variableName]),
                                                                                            annotation: /* Some */[/* OptionalType */Block.__(4, [/* TypeName */Block.__(0, ["NSLayoutConstraint"])])]
                                                                                          }]),
                                                                                      init: /* None */0,
                                                                                      block: /* None */0
                                                                                    }]);
                                                                        }), constraints),
                                                                  /* :: */[
                                                                    /* :: */[
                                                                      setUpViewsDoc(rootLayer),
                                                                      /* [] */0
                                                                    ],
                                                                    /* :: */[
                                                                      /* :: */[
                                                                        setUpConstraintsDoc(rootLayer),
                                                                        /* [] */0
                                                                      ],
                                                                      /* :: */[
                                                                        /* :: */[
                                                                          updateDoc(/* () */0),
                                                                          /* [] */0
                                                                        ],
                                                                        /* :: */[
                                                                          needsTracking ? AppkitPressable$LonaCompilerCore.mouseTrackingFunctions(rootLayer, pressableLayers) : /* [] */0,
                                                                          /* [] */0
                                                                        ]
                                                                      ]
                                                                    ]
                                                                  ]
                                                                ]
                                                              ]
                                                            ]
                                                          ]
                                                        ]
                                                      ]
                                                    ]
                                                  ]
                                                ]
                                              ]
                                            ]
                                          ]
                                        ]
                                      ])
                                }]),
                            /* [] */0
                          ],
                          /* [] */0
                        ]
                      ]
                    ]
                  ])
            }]);
}

var Ast = 0;

var Document = 0;

var Render = 0;

exports.Ast = Ast;
exports.Document = Document;
exports.Render = Render;
exports.isFunctionParameter = isFunctionParameter;
exports.generate = generate;
/* lodash.upperfirst Not a pure module */
